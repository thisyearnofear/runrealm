const hre = require("hardhat");
const fs = require("fs");
const path = require("path");

/**
 * ENHANCED DEPLOYMENT SCRIPT - ZetaChain Universal Contract
 * Following Core Principles:
 * - ENHANCEMENT FIRST: Leverages ZetaChain's proven infrastructure
 * - AGGRESSIVE CONSOLIDATION: Single deployment for all functionality
 * - PREVENT BLOAT: Minimal, focused deployment
 * - DRY: Single source of truth for configuration
 * - CLEAN: Clear separation of concerns
 * - MODULAR: Composable deployment steps
 * - PERFORMANT: Optimized for ZetaChain
 * - ORGANIZED: Predictable structure
 */

// CLEAN: Configuration constants
const DEPLOYMENT_CONFIG = {
  // ZetaChain network configurations
  networks: {
    7001: {
      // Athens Testnet
      name: "zetachain_testnet",
      gateway: "0x6c533f7fe93fae114d0954697069df33c9b74fd7",
      systemContract: "0x239e96c8f17C85c30100AC26F635Ea15f23E9c67",
      uniswapRouter: "0x2ca7d64A7EFE2D62A725E2B35Cf7230D6677FfEe",
      explorerUrl: "https://zetachain-athens-3.blockscout.com",
    },
    7000: {
      // Mainnet
      name: "zetachain_mainnet",
      gateway: "0x6c533f7fe93fae114d0954697069df33c9b74fd7",
      systemContract: "0x91d18e54DAf4F677cB28167158d6dd21F6aB3921",
      uniswapRouter: "0x2ca7d64A7EFE2D62A725E2B35Cf7230D6677FfEe",
      explorerUrl: "https://zetachain.blockscout.com",
    },
  },

  // Game configuration
  game: {
    name: "RunRealm Territory",
    symbol: "TERRITORY",
    gasLimit: 500000,
    // Supported cross-chain networks
    supportedChains: [1, 56, 137, 43114, 8453, 42161], // ETH, BSC, POLYGON, AVAX, BASE, ARB
  },
};

// MODULAR: Deployment steps
class UniversalDeployer {
  constructor(network, deployer) {
    this.network = network;
    this.deployer = deployer;
    this.config = DEPLOYMENT_CONFIG.networks[network.chainId];
    this.deployedContracts = {};
    this.deploymentRecord = {
      network: network,
      deployer: deployer.address,
      timestamp: new Date().toISOString(),
      contracts: {},
      configuration: {},
    };
  }

  // CLEAN: Logging utilities
  log(message) {
    console.log(`üîß ${message}`);
  }

  success(message) {
    console.log(`‚úÖ ${message}`);
  }

  error(message) {
    console.log(`‚ùå ${message}`);
  }

  // PERFORMANT: Deploy RealmToken with ZRC-20 compatibility
  async deployRealmToken() {
    this.log("Deploying RealmToken...");

    const RealmToken = await hre.ethers.getContractFactory("RealmToken");
    const realmToken = await RealmToken.deploy();

    await realmToken.waitForDeployment();
    const address = await realmToken.getAddress();

    this.deployedContracts.realmToken = realmToken;
    this.deploymentRecord.contracts.RealmToken = {
      address: address,
      type: "ERC20",
      name: "RunRealm Token",
      symbol: "REALM",
    };

    this.success(`RealmToken deployed: ${address}`);
    return realmToken;
  }

  // MODULAR: Deploy GameLogic library
  async deployGameLogicLibrary() {
    this.log("Deploying GameLogic library...");

    const GameLogic = await hre.ethers.getContractFactory("GameLogic");
    const gameLogic = await GameLogic.deploy();

    await gameLogic.waitForDeployment();
    const address = await gameLogic.getAddress();

    this.deployedContracts.gameLogic = gameLogic;
    this.deploymentRecord.contracts.GameLogic = {
      address: address,
      type: "Library",
      name: "GameLogic",
    };

    this.success(`GameLogic library deployed: ${address}`);
    return gameLogic;
  }

  // ENHANCEMENT FIRST: Deploy Universal Contract with ZetaChain integration
  async deployUniversalContract() {
    this.log("Deploying RunRealm Universal Contract...");

    // Link the GameLogic library
    const UniversalContract = await hre.ethers.getContractFactory(
      "RunRealmUniversal",
      {
        libraries: {
          GameLogic: this.deploymentRecord.contracts.GameLogic.address,
        },
      }
    );

    // Deploy directly (simplified without upgrades for now)
    const universal = await UniversalContract.deploy(
      this.deploymentRecord.contracts.RealmToken.address
    );

    await universal.waitForDeployment();
    const universalAddress = await universal.getAddress();

    this.deployedContracts.universal = universal;
    this.deploymentRecord.contracts.RunRealmUniversal = {
      address: universalAddress,
      type: "Universal Contract",
      name: "RunRealm Territory",
      symbol: "TERRITORY",
    };

    this.success(`Universal Contract deployed: ${universalAddress}`);
    return universal;
  }

  // DRY: Configure contract relationships
  async configureContracts() {
    this.log("Configuring contract relationships...");

    const realmToken = this.deployedContracts.realmToken;
    const universal = this.deployedContracts.universal;

    // Add universal contract as authorized minter
    await realmToken.addAuthorizedMinter(await universal.getAddress());
    this.success("Added Universal Contract as authorized minter");

    // Add universal contract as reward distributor
    await realmToken.addRewardDistributor(await universal.getAddress());
    this.success("Added Universal Contract as reward distributor");

    this.deploymentRecord.configuration = {
      authorizedMinterSet: true,
      rewardDistributorSet: true,
    };
  }

  // MODULAR: Verification and testing
  async verifyDeployment() {
    this.log("Verifying deployment...");

    const realmToken = this.deployedContracts.realmToken;
    const universal = this.deployedContracts.universal;

    // Verify RealmToken
    const tokenName = await realmToken.name();
    const tokenSymbol = await realmToken.symbol();
    const totalSupply = await realmToken.totalSupply();

    this.success(`RealmToken: ${tokenName} (${tokenSymbol})`);
    this.success(`Total Supply: ${hre.ethers.formatEther(totalSupply)} REALM`);

    // Verify Universal Contract
    const nftName = await universal.name();
    const nftSymbol = await universal.symbol();
    const gameConfig = await universal.getGameConfig();

    this.success(`Universal Contract: ${nftName} (${nftSymbol})`);
    this.success(`Base Reward Rate: ${gameConfig.baseRewardRate}`);

    // Test basic functionality
    try {
      this.log("Testing territory validation...");
      const testResult = await universal.validateTerritory(
        "u4pruydqqvj",
        50,
        1000
      );
      this.success(`Territory validation: ${testResult[0]}`);

      // Test minting (if on testnet)
      if (this.network.chainId === 7001n) {
        this.log("Testing territory minting...");
        const tx = await universal.mintTerritory(
          "test" + Date.now(), // unique geohash
          25, // difficulty
          500, // distance
          ["Test Landmark"] // landmarks
        );
        await tx.wait();
        this.success("Test territory minted successfully!");
      }
    } catch (error) {
      this.log(`Test failed (this is ok for mainnet): ${error.message}`);
    }
  }

  // ORGANIZED: Save deployment artifacts
  async saveDeployment() {
    this.log("Saving deployment artifacts...");

    // Create deployments directory
    const deploymentsDir = path.join(__dirname, "..", "deployments");
    if (!fs.existsSync(deploymentsDir)) {
      fs.mkdirSync(deploymentsDir, { recursive: true });
    }

    // Save comprehensive deployment record
    const deploymentFile = path.join(
      deploymentsDir,
      `${this.config.name}-universal.json`
    );
    fs.writeFileSync(
      deploymentFile,
      JSON.stringify(this.deploymentRecord, null, 2)
    );

    // Update app settings
    await this.updateAppSettings();

    this.success(`Deployment saved: ${deploymentFile}`);
  }

  // PREVENT BLOAT: Update only necessary configuration
  async updateAppSettings() {
    const settingsPath = path.join(
      __dirname,
      "..",
      "src",
      "appsettings.secrets.ts"
    );

    const universalAddress =
      this.deploymentRecord.contracts.RunRealmUniversal.address;
    const realmAddress = this.deploymentRecord.contracts.RealmToken.address;

    const settingsContent = `// RunRealm Universal Contract Configuration
// Auto-generated by deployment script - DO NOT EDIT MANUALLY

export const appSettings = {
  mapbox: {
    accessToken: process.env.MAPBOX_ACCESS_TOKEN || 'your-mapbox-token-here'
  },
  web3: {
    enabled: true,
    zetachain: {
      rpcUrl: process.env.ZETACHAIN_RPC_URL || '${
        this.network.chainId === 7001n
          ? "https://zetachain-athens-evm.blockpi.network/v1/rpc/public"
          : "https://zetachain-evm.blockpi.network/v1/rpc/public"
      }',
      chainId: ${this.network.chainId.toString()},
      contracts: {
        universal: '${universalAddress}',
        realmToken: '${realmAddress}',
      },
      explorerUrl: '${
        this.config
          ? this.config.explorerUrl
          : "https://zetachain-athens-3.blockscout.com"
      }'
    },
    ai: {
      geminiApiKey: process.env.GEMINI_API_KEY || 'your-gemini-api-key-here',
      enabled: true
    },
    crossChain: {
      enabled: true,
      supportedChains: [${DEPLOYMENT_CONFIG.game.supportedChains.join(", ")}]
    }
  }
};
`;

    fs.writeFileSync(settingsPath, settingsContent);
    this.success("Updated app settings");
  }

  // PERFORMANT: Contract verification on block explorer
  async verifyContracts() {
    if (this.network.name === "hardhat" || this.network.name === "localhost") {
      this.log("Skipping verification for local network");
      return;
    }

    this.log("Verifying contracts on block explorer...");

    try {
      // Verify RealmToken
      await hre.run("verify:verify", {
        address: this.deploymentRecord.contracts.RealmToken.address,
        constructorArguments: [],
      });
      this.success("RealmToken verified");

      // Verify GameLogic library
      await hre.run("verify:verify", {
        address: this.deploymentRecord.contracts.GameLogic.address,
        constructorArguments: [],
      });
      this.success("GameLogic library verified");

      // Verify Universal Contract
      await hre.run("verify:verify", {
        address: this.deploymentRecord.contracts.RunRealmUniversal.address,
        constructorArguments: [
          this.deploymentRecord.contracts.RealmToken.address,
        ],
        libraries: {
          GameLogic: this.deploymentRecord.contracts.GameLogic.address,
        },
      });
      this.success("Universal Contract verified");
    } catch (error) {
      this.log(`Verification failed (this is normal): ${error.message}`);
    }
  }
}

// CLEAN: Main deployment function
async function main() {
  console.log("üöÄ RunRealm Universal Contract Deployment");
  console.log("==========================================");

  const [deployer] = await hre.ethers.getSigners();
  const network = await hre.ethers.provider.getNetwork();

  console.log(`üìù Deployer: ${deployer.address}`);
  console.log(`üåê Network: ${hre.network.name} (${network.chainId})`);
  console.log(
    `üí∞ Balance: ${hre.ethers.formatEther(
      await hre.ethers.provider.getBalance(deployer.address)
    )}`
  );

  // Validate network
  if (!DEPLOYMENT_CONFIG.networks[network.chainId]) {
    throw new Error(
      `Unsupported network: ${network.chainId}. Supported: ${Object.keys(
        DEPLOYMENT_CONFIG.networks
      ).join(", ")}`
    );
  }

  const deployerInstance = new UniversalDeployer(network, deployer);

  try {
    // MODULAR: Execute deployment steps
    await deployerInstance.deployRealmToken();
    await deployerInstance.deployGameLogicLibrary();
    await deployerInstance.deployUniversalContract();
    await deployerInstance.configureContracts();
    await deployerInstance.verifyDeployment();
    await deployerInstance.saveDeployment();

    // Verify contracts (optional)
    await deployerInstance.verifyContracts();

    // Success summary
    console.log("\nüéâ DEPLOYMENT COMPLETE!");
    console.log("========================");
    console.log(
      `ü™ô REALM Token: ${deployerInstance.deploymentRecord.contracts.RealmToken.address}`
    );
    console.log(
      `üåç Universal Contract: ${deployerInstance.deploymentRecord.contracts.RunRealmUniversal.address}`
    );
    console.log(
      `üîç Explorer: ${
        deployerInstance.config
          ? deployerInstance.config.explorerUrl
          : "https://zetachain-athens-3.blockscout.com"
      }/address/${
        deployerInstance.deploymentRecord.contracts.RunRealmUniversal.address
      }`
    );

    console.log("\nüéØ Next Steps:");
    console.log("1. Get testnet ZETA: https://labs.zetachain.com/get-zeta");
    console.log("2. Add ZetaChain network to MetaMask");
    console.log("3. Run: npm start");
    console.log("4. Start claiming territories cross-chain!");

    return deployerInstance.deploymentRecord;
  } catch (error) {
    deployerInstance.error(`Deployment failed: ${error.message}`);
    throw error;
  }
}

// CLEAN: Error handling
main()
  .then((record) => {
    console.log("\n‚ú® RunRealm is ready for cross-chain territory gaming!");
    process.exit(0);
  })
  .catch((error) => {
    console.error("\nüí• Deployment failed:");
    console.error(error);

    // Helpful error messages
    if (error.code === "INSUFFICIENT_FUNDS") {
      console.error("üí° Get testnet ZETA: https://labs.zetachain.com/get-zeta");
    } else if (error.code === "NETWORK_ERROR") {
      console.error("üí° Check your internet connection and RPC URL");
    } else if (error.message.includes("nonce")) {
      console.error("üí° Reset your MetaMask account or wait a moment");
    }

    process.exit(1);
  });
